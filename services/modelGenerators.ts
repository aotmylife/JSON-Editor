
import { GeneratedClass, Language } from '../types';

export class ModelGenerator {
  private classes: GeneratedClass[] = [];
  private seenClasses: Set<string> = new Set();

  private toPascalCase(str: string): string {
    return str
      .replace(/[^a-zA-Z0-9]/g, ' ')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('') || 'AutoGenerated';
  }

  private toCamelCase(str: string): string {
    const pascal = this.toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }

  private toSnakeCase(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '');
  }

  private inferType(key: string, value: any, lang: Language): string {
    if (value === null) {
      switch (lang) {
        case 'KOTLIN': return "Any?";
        case 'JAVA': return "Object";
        case 'TYPESCRIPT': return "any";
        case 'SWIFT': return "Any?";
        case 'PYTHON': return "Optional[Any]";
        case 'CSHARP': return "object";
        default: return "any";
      }
    }

    if (typeof value === "string") {
      switch (lang) {
        case 'KOTLIN': return "String";
        case 'JAVA': return "String";
        case 'TYPESCRIPT': return "string";
        case 'SWIFT': return "String";
        case 'PYTHON': return "str";
        case 'CSHARP': return "string";
        default: return "string";
      }
    }

    if (typeof value === "number") {
      const isInt = Number.isInteger(value);
      switch (lang) {
        case 'KOTLIN': return isInt ? "Int" : "Double";
        case 'JAVA': return isInt ? "int" : "double";
        case 'TYPESCRIPT': return "number";
        case 'SWIFT': return isInt ? "Int" : "Double";
        case 'PYTHON': return isInt ? "int" : "float";
        case 'CSHARP': return isInt ? "int" : "double";
        default: return "number";
      }
    }

    if (typeof value === "boolean") {
      switch (lang) {
        case 'KOTLIN': return "Boolean";
        case 'JAVA': return "boolean";
        case 'TYPESCRIPT': return "boolean";
        case 'SWIFT': return "Bool";
        case 'PYTHON': return "bool";
        case 'CSHARP': return "bool";
        default: return "boolean";
      }
    }

    if (Array.isArray(value)) {
      const itemType = value.length > 0 ? this.inferType(key + "Item", value[0], lang) : (lang === 'TYPESCRIPT' ? 'any' : 'Object');
      switch (lang) {
        case 'KOTLIN': return `List<${itemType}>`;
        case 'JAVA': return `List<${itemType}>`;
        case 'TYPESCRIPT': return `${itemType}[]`;
        case 'SWIFT': return `[${itemType}]`;
        case 'PYTHON': return `List[${itemType}]`;
        case 'CSHARP': return `List<${itemType}>`;
        default: return `Array<${itemType}>`;
      }
    }

    if (typeof value === "object") {
      const className = this.toPascalCase(key);
      this.generateClass(className, value, lang);
      return className;
    }

    return "any";
  }

  private generateClass(className: string, obj: any, lang: Language) {
    if (this.seenClasses.has(className)) return;
    this.seenClasses.add(className);

    let code = "";
    const keys = Object.keys(obj);

    switch (lang) {
      case 'KOTLIN':
        code = `import com.google.gson.annotations.SerializedName\n\n`;
        code += `data class ${className}(\n`;
        keys.forEach((key, index) => {
          const type = this.inferType(key, obj[key], lang);
          const isLast = index === keys.length - 1;
          code += `    @SerializedName("${key}")\n    val ${this.toCamelCase(key)}: ${type}${isLast ? "" : ",\n"}`;
        });
        code += `\n)`;
        break;

      case 'JAVA':
        code = `import com.google.gson.annotations.SerializedName;\nimport java.util.List;\n\n`;
        code += `public class ${className} {\n`;
        keys.forEach(key => {
          const type = this.inferType(key, obj[key], lang);
          code += `    @SerializedName("${key}")\n    public ${type} ${this.toCamelCase(key)};\n\n`;
        });
        code += `}`;
        break;

      case 'TYPESCRIPT':
        code = `export interface ${className} {\n`;
        keys.forEach(key => {
          const type = this.inferType(key, obj[key], lang);
          code += `    ${key}: ${type};\n`;
        });
        code += `}`;
        break;

      case 'SWIFT':
        code = `import Foundation\n\n`;
        code += `struct ${className}: Codable {\n`;
        keys.forEach(key => {
          const type = this.inferType(key, obj[key], lang);
          code += `    let ${this.toCamelCase(key)}: ${type}\n`;
        });
        code += `\n    enum CodingKeys: String, CodingKey {\n`;
        keys.forEach(key => {
          code += `        case ${this.toCamelCase(key)} = "${key}"\n`;
        });
        code += `    }\n}`;
        break;

      case 'PYTHON':
        code = `from dataclasses import dataclass\nfrom typing import List, Optional, Any\n\n`;
        code += `@dataclass\nclass ${className}:\n`;
        keys.forEach(key => {
          const type = this.inferType(key, obj[key], lang);
          code += `    ${this.toSnakeCase(key)}: ${type}\n`;
        });
        break;

      case 'CSHARP':
        code = `using Newtonsoft.Json;\nusing System.Collections.Generic;\n\n`;
        code += `public class ${className}\n{\n`;
        keys.forEach(key => {
          const type = this.inferType(key, obj[key], lang);
          code += `    [JsonProperty("${key}")]\n    public ${type} ${this.toPascalCase(key)} { get; set; }\n\n`;
        });
        code += `}`;
        break;
    }

    this.classes.push({ className, code });
  }

  public generate(json: any, lang: Language, rootName: string = "Response"): GeneratedClass[] {
    this.classes = [];
    this.seenClasses = new Set();
    
    if (Array.isArray(json)) {
       if (json.length > 0) {
          this.generateClass(rootName, json[0], lang);
       }
    } else if (typeof json === 'object' && json !== null) {
      this.generateClass(rootName, json, lang);
    }
    
    return this.classes.reverse();
  }
}
